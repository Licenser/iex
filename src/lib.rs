//! Idiomatic exceptions.
//!
//! Speed up the happy path of your [`Result`]-based functions by seamlessly using exceptions for
//! error propagation.
//!
//! # Crash course
//!
//! Stick [`#[iex]`](macro@iex) on all the functions that return [`Result`] to make them return an
//! efficiently propagatable `#[iex] Result`, apply `?` just like usual, and occasionally call
//! [`.into_result()`](Outcome::into_result) when you need a real [`Result`]. It's that intuitive.
//!
//! Compared to an algebraic [`Result`], `#[iex] Result` is asymmetric: it sacrifices the
//! performance of error handling, and in return:
//! - Gets rid of branching in the happy path,
//! - Reduces memory usage by never explicitly storing the error or the enum discriminant,
//! - Enables the compiler to use registers instead of memory when wrapping small objects in [`Ok`],
//! - Cleanly separates the happy and unhappy paths in the machine code, resulting in better
//!   instruction cache locality.
//!
//! # Example
//!
//! ```
//! # #![feature(iterator_try_collect)]
//! use iex::{iex, Outcome};
//!
//! #[iex]
//! fn checked_divide(a: u32, b: u32) -> Result<u32, &'static str> {
//!     if b == 0 {
//!         // Actually raises a custom panic
//!         Err("Cannot divide by zero")
//!     } else {
//!         // Actually returns a / b directly
//!         Ok(a / b)
//!     }
//! }
//!
//! #[iex]
//! fn checked_divide_by_many_numbers(a: u32, bs: &[u32]) -> Result<Vec<u32>, &'static str> {
//!     let mut results = Vec::new();
//!     for &b in bs {
//!         // Actually lets the panic bubble
//!         results.push(checked_divide(a, b)?);
//!     }
//!     Ok(results)
//! }
//!
//! fn main() {
//!     // Actually catches the panic
//!     let result = checked_divide_by_many_numbers(5, &[1, 2, 3, 0]).into_result();
//!     assert_eq!(result, Err("Cannot divide by zero"));
//! }
//! ```
//!
//! # All you need to know
//!
//! Functions marked [`#[iex]`](macro@iex) are supposed to return a [`Result<T, E>`] in their
//! definition. The macro rewrites them to return an opaque type `#[iex] Result<T, E>` instead. Upon
//! calling such a function, there are two things you must _immediately_ do with its output:
//! - Either you can propagate it with `?` if it's called from another [`#[iex]`](macro@iex)
//!   function,
//! - Or you must cast it to a [`Result`] via [`.into_result()`](Outcome::into_result).
//!
//! Doing anything else to the return value, e.g. storing it in a variable and reusing later does
//! not cause UB, but will not work the way you think. If you want to swallow the error, use
//! `let _ = func().into_result();` instead.
//!
//! A [`Result`] is only slow when used across function boundaries as a return type. Using it within
//! a function is mostly fine, so don't hesitate to use [`.into_result()`](Outcome::into_result) if
//! you wish to match on the return value, extract the error, or call a combinator like
//! [`Result::or_else`].

/// Use unwinding for error propagation from a function.
///
/// Applying this attribute to a function that returns [`Result<T, E>`] turns it into a function
/// that returns `#[iex] Result<T, E>`. This is an opaque type, but it implements the [`Outcome`]
/// trait, so you can use [`.into_result()`](Outcome::into_result) to turn it into [`Result<T, E>`].
///
/// Additionally, `expr?` inside an `#[iex]` function is interpreted as a custom operator (as
/// opposed to the built-in try operator) that propagates the error from a [`Result<T, E>`] or a
/// `#[iex] Result<T, E>` and returns a `T`.
///
/// # Pitfalls
///
/// If a function takes an argument whose type has an elided lifetime parameter, this parameter must
/// be specified explicitly:
///
/// ```
/// use iex::iex;
/// use std::marker::PhantomData;
///
/// struct A<'a>(PhantomData<&'a ()>);
///
/// #[iex]
/// fn good(a: A<'_>) -> Result<(), ()> { Ok(()) }
///
/// // #[iex]
/// // fn bad(a: A) -> Result<(), ()> { Ok(()) }
/// ```
///
/// This is the conventional way to specify elided lifetimes on structs, so it shouldn't be a
/// nuisance.
///
/// # Attributes
///
/// Rust evaluates attribute macros from top to bottom, so if `#[iex]` is not the only attribute
/// macro applied to the function, the macros listed above it will be applied to the original
/// function definition, and the macros listed below it will be applied to an internal closure
/// generated by `#[iex]`.
///
/// Note that this only applies to attribute *macros*; normal attributes, such as `#[inline]` and
/// `#[cfg]`, do the right thing independently from their location.
///
/// # Documentation
///
/// `#[iex]` functions are documented (by rustdoc) to return an algebraic [`Result`], just like in
/// source code, but they also have a `#[iex]` macro attached to their signature. This is a
/// sufficient indicator for those who know what `#[iex]` is, but if you use `#[iex]` in the public
/// API of a library, you probably want to write that down in prose.
///
/// For a rendered example, see [`example::add`].
///
/// # Example
///
/// ```
/// // The Outcome trait is required for .into_result()
/// use iex::{iex, Outcome};
///
/// fn returning_regular_result<E>(err: E) -> Result<(), E> { Err(err) }
///
/// #[iex]
/// fn returning_iex_result<E>(err: E) -> Result<(), E> { Err(err) }
///
/// #[iex]
/// fn test() -> Result<i32, String> {
///     // ? can be applied to a Result<_, String>
///     returning_regular_result("Some error happened!".to_string())?;
///
///     // ? can be applied to a Result<_, impl Into<String>> too
///     returning_regular_result("Some error happened!")?;
///
///     // The same applies to #[iex] Result
///     returning_iex_result("Some error happened!".to_string())?;
///     returning_iex_result("Some error happened!")?;
///
///     // You can also directly return a Result
///     Ok(123)
/// }
///
/// fn main() {
///     // Using an #[iex] function from a regular function requires a cast
///     let _result: Result<i32, String> = test().into_result();
/// }
/// ```
///
/// This attribute can only be applied to functions that return a [`Result`]:
///
/// ```compile_fail
/// # use iex::iex;
/// // the trait `Outcome` is not implemented for `Option<()>`
/// #[iex]
/// fn invalid_example() -> Option<()> {
///     None
/// }
/// ```
///
/// ```compile_fail
/// # use iex::iex;
/// // the trait `Outcome` is not implemented for `()`
/// #[iex]
/// fn invalid_example() {}
/// ```
pub use iex_derive::iex;

use std::cell::Cell;
use std::marker::PhantomData;
use std::panic::AssertUnwindSafe;

struct IexPanic;

thread_local! {
    static EXCEPTION: Cell<*mut ()> = const { Cell::new(std::ptr::null_mut()) };
}

mod sealed {
    pub trait Sealed {}
}

/// Properties of a generalized result type.
///
/// This unifies [`Result`] and `#[iex] Result`.
#[must_use]
pub trait Outcome: sealed::Sealed {
    /// The type of the success value.
    type Output;

    /// The type of the error value.
    type Error;

    #[doc(hidden)]
    fn get_value_or_panic<F>(self, marker: imp::Marker<F>) -> Self::Output
    where
        Self::Error: Into<F>;

    /// Cast a generic result to a [`Result`].
    ///
    /// The [`Result`] can then be matched on, returned from a function that doesn't use
    /// [`#[iex]`](macro@iex), etc.
    fn into_result(self) -> Result<Self::Output, Self::Error>;
}

impl<T, E> sealed::Sealed for Result<T, E> {}
impl<T, E> Outcome for Result<T, E> {
    type Output = T;

    type Error = E;

    fn get_value_or_panic<F>(self, _marker: imp::Marker<F>) -> T
    where
        E: Into<F>,
    {
        self.unwrap_or_else(|error| {
            EXCEPTION.set(Box::into_raw(Box::new(error.into())).cast());
            std::panic::resume_unwind(Box::new(IexPanic))
        })
    }

    fn into_result(self) -> Self {
        self
    }
}

struct ExceptionConverter<TyFrom: Into<TyTo>, TyTo>(PhantomData<fn(TyFrom) -> TyTo>);

impl<TyFrom: Into<TyTo>, TyTo> Drop for ExceptionConverter<TyFrom, TyTo> {
    fn drop(&mut self) {
        if typeid::of::<TyFrom>() == typeid::of::<TyTo>() {
            // SAFETY: If we enter this conditional, TyFrom and TyTo differ only in lifetimes.
            // Lifetimes are erased in runtime, so `impl Into<TyTo> for TyFrom` has the same
            // implementation as `impl Into<T> for T` for some `T`, and that blanket implementation
            // is a no-op. Therefore, no conversion needs to happen.
            return;
        }

        // Resolve TLS just once
        EXCEPTION.with(|exception| {
            let error_ptr: *mut TyFrom = exception.get().cast();
            if error_ptr.is_null() {
                return;
            }
            let error: TyFrom = *unsafe { Box::from_raw(error_ptr) };
            let error: TyTo = error.into();
            exception.set(Box::into_raw(Box::new(error)).cast());
        })
    }
}

#[doc(hidden)]
pub mod imp {
    use super::*;

    pub use fix_hidden_lifetime_bug::fix_hidden_lifetime_bug;

    pub struct Marker<F>(PhantomData<F>);

    impl<F> Clone for Marker<F> {
        fn clone(&self) -> Self {
            *self
        }
    }

    impl<F> Copy for Marker<F> {}

    pub struct IexResult<T, E, Func: FnOnce(Marker<E>) -> T>(Func, PhantomData<fn() -> E>);

    impl<T, E, Func: FnOnce(Marker<E>) -> T> IexResult<T, E, Func> {
        pub fn new(f: Func) -> Self {
            Self(f, PhantomData)
        }
    }

    impl<T, E, Func: FnOnce(Marker<E>) -> T> sealed::Sealed for IexResult<T, E, Func> {}
    impl<T, E, Func: FnOnce(Marker<E>) -> T> Outcome for IexResult<T, E, Func> {
        type Output = T;
        type Error = E;

        fn get_value_or_panic<F>(self, _marker: Marker<F>) -> T
        where
            E: Into<F>,
        {
            let exception_converter = ExceptionConverter::<E, F>(PhantomData);
            let output = self.0(Marker(PhantomData));
            std::mem::forget(exception_converter);
            output
        }

        fn into_result(self) -> Result<T, E> {
            std::panic::catch_unwind(AssertUnwindSafe(|| self.0(Marker(PhantomData)))).map_err(
                |payload| {
                    if payload.downcast_ref::<IexPanic>().is_some() {
                        let error_ptr = EXCEPTION.replace(std::ptr::null_mut()).cast();
                        *unsafe { Box::from_raw(error_ptr) }
                    } else {
                        std::panic::resume_unwind(payload)
                    }
                },
            )
        }
    }
}

extern crate self as iex;

pub mod example {
    use crate::iex;

    /// Add numbers and check for overflow.
    ///
    /// This function tries to compute the sum of the two arguments and returns an error if the sum
    /// doesn't fit in the result type. The returned error is the overflowed sum.
    #[iex]
    pub fn add(a: i32, b: i32) -> Result<i32, i32> {
        a.checked_add(b).ok_or(a.wrapping_add(b))
    }
}
